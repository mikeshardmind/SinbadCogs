import asyncio
import datetime

from typing import Any, Optional, Union, TypeVar, Generic, Type, Awaitable, Generator, Callable, Sequence, overload
from typing_extensions import Final

MAX_ASYNCIO_SECONDS: Final[int]

_T = TypeVar('_T')
_L = TypeVar('_L', bound=Loop)
_CoroType = Callable[..., Union[Awaitable[_T], Generator[Any, None, _T]]]
_C = TypeVar('_C', bound=Callable[..., Awaitable[Any]])

class Loop(Generic[_T]):
    coro: _CoroType[_T] = ...
    seconds: float = ...
    hours: float = ...
    minutes: float = ...
    reconnect: bool = ...
    loop: asyncio.AbstractEventLoop = ...
    count: Optional[int] = ...
    @overload
    def __init__(self, coro: _CoroType[_T], seconds: float, hours: float,
                 minutes: float, count: Optional[int], reconnect: bool,
                 loop: Optional[asyncio.AbstractEventLoop]) -> None: ...
    @overload
    def __init__(self, coro: _CoroType[_T], time: Union[Sequence[datetime.time], datetime.time],
                 count: Optional[int], reconnect: bool,
                 loop: Optional[asyncio.AbstractEventLoop]) -> None: ...
    def __get__(self: _L, obj: Any, objtype: Any) -> _L: ...
    @property
    def current_loop(self) -> int: ...
    def start(self, *args: Any, **kwargs: Any) -> asyncio.Task[_T]: ...
    def stop(self) -> None: ...
    def cancel(self) -> None: ...
    def restart(self, *args: Any, **kwargs: Any) -> None: ...
    def add_exception_type(self, *exceptions: Type[BaseException]) -> None: ...
    def clear_exception_types(self) -> None: ...
    def remove_exception_type(self, *exceptions: Type[BaseException]) -> bool: ...
    def get_task(self) -> asyncio.Task[_T]: ...
    def is_being_cancelled(self) -> bool: ...
    def failed(self) -> bool: ...
    def exception(self) -> Exception: ...
    def before_loop(self, coro: _C) -> _C: ...
    def after_loop(self, coro: _C) -> _C: ...
    @overload
    def change_interval(self, *, seconds: float = ..., minutes: float = ..., hours: float = ...) -> None: ...
    @overload
    def change_interval(self, *, time: Union[Sequence[datetime.time], datetime.time]) -> None: ...

@overload
def loop(*, seconds: float = ..., minutes: float = ..., hours: float = ...,
         count: Optional[int] = ..., reconnect: bool = ...,
         loop: Optional[asyncio.AbstractEventLoop] = ...) -> Callable[[_CoroType[_T]], Loop[_T]]: ...
@overload
def loop(*, time: Union[Sequence[datetime.time], datetime.time],
         count: Optional[int] = ..., reconnect: bool = ...,
         loop: Optional[asyncio.AbstractEventLoop] = ...) -> Callable[[_CoroType[_T]], Loop[_T]]: ...
